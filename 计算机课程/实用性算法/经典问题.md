
## 图
### SSSP

#### Dijistra
  每次选取一个离s最近的未知点, 用该点更新所有未知点的最短路径
```cpp
int n, m, s, e; // 节点数, 有向线段数, 起点, 终点
int graph[size][size]; // 图的邻接矩阵
int dist[size]; // 起点到各点的最短距离
bool visited[size]; // 记录节点是否被访问过
void dijkstra(int s)
{
	for(int i=1; i<=n; i++){
		dist[i] = max;
		visited[i] = false;
	} 
	dist[s] = 0;
	for(int i=1; i<=n; i++) // 遍历所有节点
	{
		int min = max, u = -1;
		for(int j=1; j<=n; j++) 
			if(dist[j] < min && !visited[j])
				u = j; min = dist[j];
				
		if(u == -1) return;
		visited[u] = true; 
		for(int v=1; v<=n; v++) 
			if(!visited[v] && graph[u][v] != max &&
				dist[v] > dist[u] + graph[u][v]) 
				dist[v] = dist[u] + graph[u][v];
	}
}
```


#### Bellman-Ford
  
  松弛n-1次,每次使用所有的边分别松弛, 更新到达该边目的点的最短路径. 
```cpp
int n, m;       // n表示点数，m表示边数
int dist[N];    // dist[x]存储1到x的最短路距离
struct Edge{int a, b, w;}edges[M];
int bellman_ford()
{
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	for (int i = 0; i < n; i ++ )
	{
		for (int j = 0; j < m; j ++ )
		{
			int a = edges[j].a, b = edges[j].b, w = edges[j].w;
			if (dist[b] > dist[a] + w)
				dist[b] = dist[a] + w;
		}
	}
	if (dist[n] > 0x3f3f3f3f / 2) return -1;
	return dist[n];
}
// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
```

```cpp
double dist[10000+1];
class Solution {
public:
    double maxProbability(int n, 
    vector<vector<int>>& edges, vector<double>& succProb, 
    int start_node, int end_node) 
    {
        int edgeNum=edges.size();
        memset(dist,0,10001*8);
        dist[start_node]=1;
        int exitMark=1;
        while(exitMark){
            exitMark=0;
            for(int i=0;i<edgeNum;i++)
            {
                int src=edges[i][0];
                int dst=edges[i][1];
                double weight=succProb[i];
                if(dist[src]*weight>dist[dst])
                {
                    dist[dst]=dist[src]*weight;
                    exitMark=1;
                }
                if(dist[dst]*weight>dist[src])
                {
                    dist[src]=dist[dst]*weight;
                    exitMark=1;
                }
                    
            }
        }
        if(dist[end_node]>=0)
            return dist[end_node];
        return 0;
    }
};
// 1.使用while加速 2.无向图每轮需要收缩两次
```


### APSP

#### Floyd-warshall
  
  根据任意两点之间的节点数进行迭代. 三重循环.
  
  ```c
  //初始化dist[][][0]
  dist[i][j][0]=min{ e[i][j],INF }
  //迭代
  for(int k=1;k<n;k++)
	  for(int i=1;i<n;i++)
		  for(int j=1;j<n;j++)
			  if(dist[i][k][k-1]+dist[k][j][k-1]<dist[i][j][k-1])
				  dist[i][j][k]=dist[i][k][k-1]+dist[k][j][k-1];
  ```

### 最小生成树

#### prime (node)
  
  每次选取一个离 S 最近的未知点, 用该更新所有未知点到S的距离.
  
  ```c
  while (true)
  {
	  int best = -1;
	  // 遍历所有未使用点，找到最优点( 与S最近的点 )
	  for (int ord = 0; ord < nodeN; ord++)
	  {
		  if (!used[ord]&&(best == -1 || dist[ord] < dist[best])) 
		  {
			  best = ord;
		  }
	  }
	  // A. 未找到则结束
	  if (best == -1){
		  break;
	  }
	  // B. 找到则加入最小生成树.
	  used[best] = true;
	  res += dist[best];
	  //更新 S 经过 best 到所有点的距离 dist
	  for (int ord = 0; ord < nodeN; ord++)
	  {
		  dist[ord]=min(edge[best][ord], dist[ord]);
	  }
  }
  ```

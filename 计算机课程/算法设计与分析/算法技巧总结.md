---
tags:
---


双指针法
- 快慢指针: 检查是否为循环链表


# 应用

## 素数相关

 埃氏筛
 按顺序第一次遇到的一定是素数.
 ```cpp
 class Solution {
 public:
     int countPrimes(int n) {
         vector<int>isPrime(n,1);
         int count=0;
         for(int i=2;i<n;i++){
             if(isPrime[i]==1){
                 count++;
                 for(long long ord=(long long)i*i;ord<n;ord+=i)
                 {
                     isPrime[ord]=0;
                 }
             }
         }
         return count;
     }
 };
 ```

## 树

数组并查集
```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n=isConnected.size();
        if(n==0)
            return false;
        int *join=new int[n];
        for(int i=0;i<n;i++)
        {
            join[i]=i;
        }
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(isConnected[i][j]==1)
                {
                    //找到i集合代表
                    int sym=i;
                    while(sym!=join[sym])
                    {
                        sym=join[sym];
                    }

                    //将j集合所有代表添加到i集合
                    int poi=j;
                    while(poi!=join[poi])
                    {
                        int temp=poi;
                        poi=join[poi];
                        join[temp]=sym;
                    }
                    join[poi]=sym;
                
                }
                    
            }
        }
        // 重要,确保所有节点到根节点距离为1
        for(int i=0;i<n;i++)
        {
            int prev=join[i];
            if(join[prev]!=prev)
            {
                int dest=prev;
                while(dest!=join[dest])
                {
                    dest=join[dest];
                }
                join[i]=dest;
            }
        }
		//计数
        set<int>s;
        for(int i=0;i<n;i++)
        {
            s.insert(join[i]);
        }
        return s.size();

    }
};
```


二叉树DP
```cpp
class Solution {
public:
    unordered_map <TreeNode*, int> f, g;

    void dfs(TreeNode* node) {
        if (!node) {
            return;
        }
        dfs(node->left);
        dfs(node->right);
        f[node] = node->val + g[node->left] + g[node->right];
        g[node] = max(f[node->left], g[node->left]) 
		        + max(f[node->right], g[node->right]);
    }

    int rob(TreeNode* root) {
        dfs(root);
        return max(f[root], g[root]);
    }
};
```
## DP


## 矩阵

### 二维前缀和

![[Pasted image 20240708162436.png]]


---
Author : orgaworl@outlook.com
Github : [orgaworl/Course-Notes: SDU CyberScience (github.com)](https://github.com/orgaworl/Course-Notes)
Create: `2024-06-01` `21:15`



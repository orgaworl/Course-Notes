---
date created: 2024-09-22 11:12
---

## 图

### SSSP

#### Dijistra

每次选取一个离s最近的未知点, 用该点更新所有未知点的最短路径

```cpp
int n, m, s, e; // 节点数, 有向线段数, 起点, 终点
int graph[size][size]; // 图的邻接矩阵
int dist[size]; // 起点到各点的最短距离
bool visited[size]; // 记录节点是否被访问过
void dijkstra(int s)
{
	for(int i=1; i<=n; i++){
		dist[i] = max;
		visited[i] = false;
	} 
	dist[s] = 0;
	for(int i=1; i<=n; i++) // 遍历所有节点
	{
		int min = max, u = -1;
		for(int j=1; j<=n; j++) 
			if(dist[j] < min && !visited[j])
				u = j; min = dist[j];
				
		if(u == -1) return;
		visited[u] = true; 
		for(int v=1; v<=n; v++) 
			if(!visited[v] && graph[u][v] != max &&
				dist[v] > dist[u] + graph[u][v]) 
				dist[v] = dist[u] + graph[u][v];
	}
}
```

#### Bellman-Ford
1. 有向图每回合收缩一次, 无向图每回合收缩两次.
2. 存在第n-1次收缩则说明存在负权回路.
3. 允许存在负权边.

Ver1.0
松弛n-1次,每次使用所有的边分别松弛, 更新到达该边目的点的最短路径.

```cpp
int n, m;       // n表示点数，m表示边数
int dist[N];    // dist[x]存储1到x的最短路距离
struct Edge{int a, b, w;}edges[M];
int bellman_ford()
{
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	for (int i = 0; i < n; i ++ )
	{
		for (int j = 0; j < m; j ++ )
		{
			int a = edges[j].a, b = edges[j].b, w = edges[j].w;
			if (dist[b] > dist[a] + w)
				dist[b] = dist[a] + w;
		}
	}
	if (dist[n] > 0x3f3f3f3f / 2) return -1;
	return dist[n];
}
// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
```

Ver2.0
```cpp
double dist[10000+1];
class Solution {
public:
    double maxProbability(int n, 
    vector<vector<int>>& edges, vector<double>& succProb, 
    int start_node, int end_node) 
    {
        int edgeNum=edges.size();
        memset(dist,0,10001*8);
        dist[start_node]=1;
        int exitMark=1;
        while(exitMark){
            exitMark=0;
            for(int i=0;i<edgeNum;i++)
            {
                int src=edges[i][0];
                int dst=edges[i][1];
                double weight=succProb[i];
                if(dist[src]*weight>dist[dst])
                {
                    dist[dst]=dist[src]*weight;
                    exitMark=1;
                }
                if(dist[dst]*weight>dist[src])
                {
                    dist[src]=dist[dst]*weight;
                    exitMark=1;
                }
                    
            }
        }
        if(dist[end_node]>=0)
            return dist[end_node];
        return 0;
    }
};
// 1.使用while加速: 当一回合中不存在可收缩边时,无法再收缩,直接结束
// 2.无向图每轮需要收缩两次
```

### APSP

#### Floyd-warshall

根据任意两点之间的节点数(前k个节点)进行迭代. 三重循环.

```c
//初始化dist[][][0]
dist[i][j][0]=min{ e[i][j],INF }
//迭代
for(int k=1;k<n;k++)
    for(int i=1;i<n;i++)
  	  for(int j=1;j<n;j++)
  		  if(dist[i][k][k-1]+dist[k][j][k-1]<dist[i][j][k-1])
  			  dist[i][j][k]=dist[i][k][k-1]+dist[k][j][k-1];
```

### 最小生成树

#### prime (node)

每次选取一个离 S 最近的未知点, 用该点更新所有未知点到S的距离.

```c
while (true)
{
    int best = -1;
    // 遍历所有未使用点，找到最优点( 与S最近的点 )
    for (int ord = 0; ord < nodeN; ord++)
    {
  	  if (!used[ord]&&(best == -1 || dist[ord] < dist[best])) 
  	  {
  		  best = ord;
  	  }
    }
    // A. 未找到则结束
    if (best == -1){
  	  break;
    }
    // B. 找到则加入最小生成树.
    used[best] = true;
    res += dist[best];
    //更新 S 经过 best 到所有点的距离 dist
    for (int ord = 0; ord < nodeN; ord++)
    {
  	  dist[ord]=min(edge[best][ord], dist[ord]);
    }
}
```

---

## 树

### DFS

二叉树 深度优先搜索 DFS

```cpp
class Solution {
public:
    unordered_map <TreeNode*, int> f, g;

    void dfs(TreeNode* node) {
        if (!node) {
            return;
        }
        dfs(node->left);
        dfs(node->right);
        f[node] = node->val + g[node->left] + g[node->right];
        g[node] = max(f[node->left], g[node->left]) 
		        + max(f[node->right], g[node->right]);
    }

    int rob(TreeNode* root) {
        dfs(root);
        return max(f[root], g[root]);
    }
};
```

---

## 数论

#### 拓展欧几里得

```cpp
int exgcd(int a,int b,int& x,int& y) {
    if (b==0) {
        x=1,y=0;
        return a;
    }
    int ret=exgcd(b,a%b,x,y);
    int t=x;
    x=y,y=t-(a/b)*y;
    return ret;
}
```

#### CRT

```cpp
int CRT(int a[],int m[],int n) {
    int ans=0,M=1;
    for (int i=1; i<=n; i++)
        M*=m[i];
    for (int i=1; i<=n; i++) {
        int Mi=M/m[i];
        exgcd(Mi,m[i],x,y);
        ans=(ans+x*a[i]*Mi)%M;
    }
    if (ans<0) {
        ans+=M;
    }
    return ans;
}
```

### 素数检测

**埃氏筛**
按顺序第一次遇到的一定是素数.

```cpp
class Solution {
public:
    int countPrimes(int n) {
        vector<int>isPrime(n,1);
        int count=0;
        for(int i=2;i<n;i++){
            if(isPrime[i]==1){
                count++;
                for(long long ord=(long long)i*i;ord<n;ord+=i)
                {
                    isPrime[ord]=0;
                }
            }
        }
        return count;
    }
};
```

gcd

```cpp
int gcd(int a, int b) {
	while (b != 0) {
		int temp = a % b;
		a = b;
		b = temp;
	}
	return a;
}
```

## 双指针

### 快慢指针: 检查是否为循环链表

## DP

> 当前 DP 计算只依赖于上一轮 DP 计算, 则使用一维数组可能会"写覆盖"导致出错, 可以改用二维数组或双一维数组.

### 矩阵二维前缀和

![[Pasted image 20240708162436.png]]

```cpp
class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int m=mat.size();
        int n=mat[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0]=mat[0][0];
	    // gen dp table
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(i==0 && j==0)
                {
                }
                else if(i==0 && j!=0)
                    dp[i][j]=dp[i][j-1]+mat[i][j];
                else if(i!=0 && j==0)
                    dp[i][j]=dp[i-1][j]+mat[i][j];
                else
                    dp[i][j]=dp[i][j-1]+dp[i-1][j]+mat[i][j]-dp[i-1][j-1];
            }
        }
	    // use dp table to cal all result
        vector<vector<int>> res(m,vector<int>(n,0));
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                int x1=j-k,x2=j+k,y1=i-k,y2=i+k;
                if(y1<=0)
                    y1=0;
                if(y2>=m)
                    y2=m-1;
                if (x1<=0)
                    x1=0;
                if(x2>=n)
                    x2=n-1;

                if(x1==0 && y1==0)
                {
                    res[i][j]=dp[y2][x2];
                }
                else if(x1==0 && y1!=0)
                {
                    res[i][j]=dp[y2][x2]-dp[y1-1][x2];
                }
                else if(x1!=0 && y1==0)
                {
                    res[i][j]=dp[y2][x2]-dp[y2][x1-1];
                }
                else if(x1!=0 && y1!=0)
                {
                    res[i][j]= dp[y2][x2]-dp[y1-1][x2] 
	                    -dp[y2][x1-1]+dp[y1-1][x1-1];
                } 
            }
        }
        return res;
    }
};
```

### **图-以中间节点个数和终点进行DP**

```cpp
int matrix[5][10];
class Solution {
public:
    int numWays(int n, vector<vector<int>>& relation, int k) {
        memset(matrix,0,50*4);
        for(int dis=0;dis<k;dis++)
        {
            for(auto p=relation.begin();p!=relation.end();p++)
            {
                int src=(*p)[0];
                int dst=(*p)[1];
                if(dis==0)
                {
                    if(src==0)
                        matrix[dis][dst]=1;
                }else
                {
                    if(matrix[dis-1][src]!=0)
                        matrix[dis][dst]+=matrix[dis-1][src];
                }
            }
        }
        return matrix[k-1][n-1];
    }
};
```

## 并查集

```cpp
int p[200000];
int find(int x) {
    if (p[x]!=x) {
        p[x] = find(p[x]);
    }
    return p[x];
}
void unite(int a, int b) {
    int pa = find(a), pb = find(b);
    if (pa == pb) return;
    p[pa] = pb;
}

class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, 
				   int source, int destination) {
        for(int i=0;i<n;i++)
        {
            p[i]=i;
        }
        int m=edges.size();
        for(int i=0;i<m;i++)
        {
            int a=edges[i][0];
            int b=edges[i][1];
            unite(min(a,b),max(a,b));
        }
        if(find(source)==find(destination))
        {
            return true;
        }
        return false;
    }
};
```

数组并查集

```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n=isConnected.size();
        if(n==0)
            return false;
        int *join=new int[n];
        for(int i=0;i<n;i++)
        {
            join[i]=i;
        }
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(isConnected[i][j]==1)
                {
                    //找到i集合代表
                    int sym=i;
                    while(sym!=join[sym])
                    {
                        sym=join[sym];
                    }

                    //将j集合所有代表添加到i集合
                    int poi=j;
                    while(poi!=join[poi])
                    {
                        int temp=poi;
                        poi=join[poi];
                        join[temp]=sym;
                    }
                    join[poi]=sym;
                
                }
                    
            }
        }
        // 重要,确保所有节点到根节点距离为1
        for(int i=0;i<n;i++)
        {
            int prev=join[i];
            if(join[prev]!=prev)
            {
                int dest=prev;
                while(dest!=join[dest])
                {
                    dest=join[dest];
                }
                join[i]=dest;
            }
        }
		//计数
        set<int>s;
        for(int i=0;i<n;i++)
        {
            s.insert(join[i]);
        }
        return s.size();

    }
};
```

## 栈

**以O(1)时间获取栈中所有元素的最小值**
添加额外栈保存不同状态下最小值.

```cpp
class MinStack {
public:
    vector<int> stack1;
    vector<int> stack2;
    /** initialize your data structure here. */
    MinStack() {
        stack1.clear();
        stack2.clear();
    }
    void push(int x) {
        if (stack1.size() == 0) {
            stack1.push_back(x);
            stack2.push_back(x);
        } else {
            stack1.push_back(x);
            int prev = stack2.back();
            stack2.push_back(prev < x ? prev : x);
        }
    }
    void pop() {
        stack1.pop_back();
        stack2.pop_back();
    }
    int top() { return stack1.back(); }
    int getMin() { return stack2.back(); }
};

```

## 滑动窗口

问题描述: 移动窗口，找到不超过限制的最大窗口.

```cpp
//移动窗口，找到满足条件的窗口
        int winsize = 0;//最大窗口的大小
        int left = 0;//窗口的左边界
        for (int i = 0; i < s.size(); i++) {
            //将当前字符加入窗口
            nums[s[i] - 'a']--;
            //如果窗口不满足条件则不断移动左指针
            while (nums[s[i] - 'a'] < 0) {
                nums[s[left] - 'a']++;
                left++;
            }
            //更新最大窗口的结果
            winsize = max(winsize, i - left + 1);
        }
        //如果能取到，则返回对应的最小窗口（不能取到的情况开始就考虑过了）
        return s.size() - winsize;
```

---

Author : <orgaworl@outlook.com>
Github : [orgaworl/Course-Notes: SDU CyberScience (github.com)](https://github.com/orgaworl/Course-Notes)
Create: `2024-06-01` `21:15`

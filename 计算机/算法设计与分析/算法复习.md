# 算法复习

## 1. Intro

### 1.1Concept

Algorithm Disign
- Modeling
- Disign
- Prove
- Evaluation
### 1.2 Algorithm
- Brute-Force

### 1.3 Problem

---

## 2. Complexity

### 2.1 Basic Concept

问题描述
- 指定问题的一组参数（集合、变量、函数、序列等），包括对域和它们之间关系的描述
- 解决方案的定义：由优化目标或约束条件决定

实例
- 参数的分配→ 问题的实例

算法
- 算法A是一个定义明确的、可由计算机执行的指令的有限序列，用于解决一类问题.
- 算法总是毫不含糊的.
- 用于执行计算、数据处理、自动推理和其他任务的规范.

问题P的算法A
- 将P的任何实例作为A的输入，每个步骤的计算都是确定的。
- A在有限的步骤中停止.
- 总是输出正确的解

Basic Computer Steps
- 抽象原子操作

Input size
- 实例的规模,对应一组问题.

算法效率度量
- 以输入规模的函数

### 2.2 three cases
- best
- worst
- averager
密码学中的困难问题假设要求在任意情况下都是困难的.

### 2.3 pseudocode

$$
Array\ P[0,...,n] \in R^{n+1}

$$

### 2.4 阶

上下界

- 紧上界/紧下界

- 松上界/松下界

notation

- 输入大小趋于正无穷时函数的极限
- $O/\Omega$ 能描述紧和松
- $o/\omega$  描述非紧
- $\Theta$      同时描述紧上下界

多变量notation

性质

- Big O
  
  - 传递链
  
  - 乘法
  
  - 加法

### 2.5 Example

- n个节点图,是否存在k个节点使得任意两个都不相连.

### 2.6 多项式时间

算法有效 <-> 多项式运行时间

---

## 4. DC

Select P

- 最大/最小/第二大
  
  线性

- general select
  
  $n\log n$
  
  $n\log k$
  
  $O(n)$

---

## 5. DP

根据子问题数量分类

1. $O(n)$
   
   - DAG                      $O(E)$
   
   - LIS 最长递增序列 $O(E)$
   
   - MIS 最大子段和   $O(N)$
   
   - 图像压缩              $O(256n)$

2. $O(n^2)$
   
   - 矩阵链乘 时间      $O(n^3)$
   
   - 最优二叉搜索树    $O(n^3)$

3. $O(nm)$
   
   - ROI  $O(nm^2)$
   
   - 背包 
   
   - 最长公共子序列
   
   - 编辑距离

---

## 6. Greedy

---

## 7. BACK

---

## 8. N&NP

1. NP-hard
   
   - 背包

2. NP-C
   
   - 0-1整数规划 (0-1背包)
   
   - 最大割
   
   - 背包

3. NP
   
   - SAT
   
   - 3-SAT
   
   - Hamiton

---

## 8. RandomA

## 9. ProblomSum

### 排序问题:

### 图论问题:

#### SSSP

1. Dijistra
  每次选取一个离s最近的未知点, 用该点更新所有未知点的最短路径
```cpp
int n, m, s, e; // 节点数, 有向线段数, 起点, 终点
int graph[size][size]; // 图的邻接矩阵
int dist[size]; // 起点到各点的最短距离
bool visited[size]; // 记录节点是否被访问过
void dijkstra(int s)
{
	for(int i=1; i<=n; i++){
		dist[i] = max;
		visited[i] = false;
	} 
	dist[s] = 0;
	for(int i=1; i<=n; i++) // 遍历所有节点
	{
		int min = max, u = -1;
		for(int j=1; j<=n; j++) 
			if(dist[j] < min && !visited[j])
				u = j; min = dist[j];
				
		if(u == -1) return;
		visited[u] = true; 
		for(int v=1; v<=n; v++) 
			if(!visited[v] && graph[u][v] != max &&
				dist[v] > dist[u] + graph[u][v]) 
				dist[v] = dist[u] + graph[u][v];
	}
}
```


2. Bellman-Ford
  
  松弛n-1次,每次使用所有的边分别松弛, 更新到达该边目的点的最短路径. 
```cpp
int n, m;       // n表示点数，m表示边数
int dist[N];    // dist[x]存储1到x的最短路距离
struct Edge{int a, b, w;}edges[M];
int bellman_ford()
{
	memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
	for (int i = 0; i < n; i ++ )
	{
		for (int j = 0; j < m; j ++ )
		{
			int a = edges[j].a, b = edges[j].b, w = edges[j].w;
			if (dist[b] > dist[a] + w)
				dist[b] = dist[a] + w;
		}
	}
	if (dist[n] > 0x3f3f3f3f / 2) return -1;
	return dist[n];
}
// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
```

```cpp
double dist[10000+1];
class Solution {
public:
    double maxProbability(int n, 
    vector<vector<int>>& edges, vector<double>& succProb, 
    int start_node, int end_node) 
    {
        int edgeNum=edges.size();
        memset(dist,0,10001*8);
        dist[start_node]=1;
        int exitMark=1;
        while(exitMark){
            exitMark=0;
            for(int i=0;i<edgeNum;i++)
            {
                int src=edges[i][0];
                int dst=edges[i][1];
                double weight=succProb[i];
                if(dist[src]*weight>dist[dst])
                {
                    dist[dst]=dist[src]*weight;
                    exitMark=1;
                }
                if(dist[dst]*weight>dist[src])
                {
                    dist[src]=dist[dst]*weight;
                    exitMark=1;
                }
                    
            }
        }
        if(dist[end_node]>=0)
            return dist[end_node];
        return 0;
    }
};
// 1.使用while加速 2.无向图每轮需要收缩两次
```


#### APSP

1. Floyd-warshall
  
  根据任意两点之间的节点数进行迭代. 三重循环.
  
  ```c
  //初始化dist[][][0]
  dist[i][j][0]=min{ e[i][j],INF }
  //迭代
  for(int k=1;k<n;k++)
	  for(int i=1;i<n;i++)
		  for(int j=1;j<n;j++)
			  if(dist[i][k][k-1]+dist[k][j][k-1]<dist[i][j][k-1])
				  dist[i][j][k]=dist[i][k][k-1]+dist[k][j][k-1];
  ```

#### 最小生成树

1. prime (node)
  
  每次选取一个离 S 最近的未知点, 用该更新所有未知点到S的距离.
  
  ```c
  while (true)
  {
	  int best = -1;
	  // 遍历所有未使用点，找到最优点( 与S最近的点 )
	  for (int ord = 0; ord < nodeN; ord++)
	  {
		  if (!used[ord]&&(best == -1 || dist[ord] < dist[best])) 
		  {
			  best = ord;
		  }
	  }
	  // A. 未找到则结束
	  if (best == -1){
		  break;
	  }
	  // B. 找到则加入最小生成树.
	  used[best] = true;
	  res += dist[best];
	  //更新 S 经过 best 到所有点的距离 dist
	  for (int ord = 0; ord < nodeN; ord++)
	  {
		  dist[ord]=min(edge[best][ord], dist[ord]);
	  }
  }
  ```

4. kruskal (edge)

2|E| · O(log |V |)

将所有边排序,不断选取不会产生环路的最短边,直到选取n-1条边.

#### 环路检查
1. 并查集 检查无向图有无环路.
6. TSP
    NP-hard problem

### Knapsack背包问题

1. 可分背包问题 - 贪心

2. 有限数量限制背包
   
   0-1 背包   NP-hard DP

3. 无限可重背包

4. 多背包

5. 二维背包

背包问题的决策版本是N-P-COMPLETE。

### 序列问题

1. 最长单调递增子序列
   
   - DP解法
   
   - 优化DP

2. 最长共同子序列

3. 最长

### Other

- random access
  
  hash map $O(1)$

- Return on Investment (ROI) Problem
  
  DP

- Single Machine Scheduling(SMS) Problem
  
  Greedy:shortest processing time (SPT) first

- 素性检测
  
  - 暴力

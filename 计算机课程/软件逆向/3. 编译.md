---
tags:
  - 逆向
---
---
## 1. 基础

一个标准线程由线程 ID, 指令指针 PC, 寄存器集合, 堆栈组成
![[Pasted image 20240603161948.png|500]]


---
## 2. 编译过程

### 完整过程

- 预处理 
	-  `gcc -E` `.cpp => .i`
	- 处理 `#` 预编译指令
		- 展开 `#define` 宏定义
		- 处理 `#ifdef` 等 条件预编译指令
		- 处理 `#include` 预编译指令
		- 删除注释 `//`
		- 添加行号和文件名标识
	- 进行文本替换
- 编译 cc1
	-  `gcc -S` `.i => .s`
	- 词法分析/扫描
	- 语法分析/ 语法树
	- 语义分析
	- 源代码优化
	- 代码生成
	- 目标代码优化
- 汇编 as
	- `gcc -c` `.s => .o`
	- 无任何优化, 根据对照表生成机器代码
- 链接 ld
	-  `gcc -` `.o => .out`
	- 将多个可重定位目标文件合并为可执行目标文件.


### 编译

1. 词法分析/扫描
	将源代码的字符序列分割为一系列记号 (Token)
	- 关键词: for while if
	- 标识量: student
	- 字面表: 1 2 3 "h"
	- 特殊符号: +-=
2. 语法分析/ 语法树
	对由扫描器产生的记号进行语法分析, 产生语法树 .
	- 对于任意子树, 先计算其左子树和右子树的结果, 再计算根节点结果.
	- 以符号和数字作为叶节点
		![[Pasted image 20240603165433.png|450]]

1. 语义分析
	编译器进行静态语义分析 (编译器即可确定的语义)
	- 声明和类型的匹配
	- 类型转换
1. 源代码优化
	- 编译器前端将语法树转换为中间语言, 即语法树的顺序表示, 与运行环境无关
	- 中间语言格式: `x = y op z`
2. 目标代码生成
	- 编译器后端(中的代码生成器)将中间语言转为目标机器汇编代码.
1. 目标代码优化
	- 编译器后端 (中的目标代码优化器)



**两次优化**



## 3. 链接

**符号**
子程序或变量的起始地址

模块间通信:
- 模块间函数调用
- 模块间变量访问
- 两者都是模块间符号的引用

### 3.1 静态链接
原理: 将指令对其他符号地址的引用进行修正;

编译目标文件时, 将目标地址设为 0, 由链接器在进行链接时将其修正.
地址修正的过程称为**重定位**, 每个修正的地方为 **重定位入口**.

合并方式
- 按序叠加
- 合并相似节: 将目标文件中的**相似节**合并为一个段segment.

#### 两部链接

合并相似节对应**两步链接**方法

1. 地址和空间分配
	扫描所有输入的目标文件, 记录所有节的长度、属性、位置, 将所有的符号定义和符号引用统一存放到全局符号表中.
	合并所有节为多个段, 计算合并后段的长度和位置, 建立映射关系.
	此过程中生成程序头表 Program-Header-Table. 
	![[Pasted image 20240604192212.png|350]]

	产生的段
	- 代码段 text (只读内存段)
	- 数据段 data (读/写内存段)
	- 不加载到内存中的符号表、调试信息


1. 符号解析与重定位
	读取节的数据和重定位数据, 进行符号解析和重定位

	符号解析: 将每个引用和可重定位目标文件符号表中一个确定的符号定义关联起来.

	多重定义的全局符号解析:
	- 定义函数和初始化全局变量为强符号
	- 未初始化全局变量为弱符号.
	- 当只存在一个强符号时, 选择强符号; 类型不同时, 选择强符号, 若存在弱符号大于强符号则警告.
	- 当不存在强符号时, 从弱符号中任意选择; 类型不同时选择最大符号.

	重定位: 
		ELF文件中的重定位表用以保存重定位相关信息.
		

	

#### 程序头表
主要描述了程序执行时在内存中的布局以及如何映射到内存中, 是对可执行二进制文件中段的描述, 程序装载时必需.

```c
typedef struct {
    Elf32_Word    p_type;     /* segment type */
    Elf32_Off     p_offset;   /* segment offset */
    Elf32_Addr    p_vaddr;    /* virtual address of segment */
    Elf32_Addr    p_paddr;    /* physical address - ignored? */
    Elf32_Word    p_filesz;   /* number of bytes in file for seg. */
    Elf32_Word    p_memsz;    /* number of bytes in mem. for seg. */
    Elf32_Word    p_flags;    /* flags */
    Elf32_Word    p_align;    /* memory alignment */
} Elf32_Phdr;
```



```c
typedef struct {
    Elf64_Half    p_type;     /* entry type */
    Elf64_Half    p_flags;    /* flags */
    Elf64_Off    p_offset;    /* offset */
    Elf64_Addr    p_vaddr;    /* virtual address */
    Elf64_Addr    p_paddr;    /* physical address */
    Elf64_Xword    p_filesz;  /* file size */
    Elf64_Xword    p_memsz;   /* memory size */
    Elf64_Xword    p_align;   /* memory & file alignment */
} Elf64_Phdr;
```


链接前每个节的VMA、LMA都为0, 链接过程中计算对应值.


### 3.2 动态链接
程序运行时进行链接

- 静态共享库(地址固定)
	- OS在某个特定地址划分处一些地址块, 为模块预留空间
	- 会导致地址冲突、升级等问题.
- 动态共享库(地址不固定)
	- 又称装载时重定位








---
## 4. 目标文件


**PE**





**ELF**




---
## 5. PE 格式目标文件

1. DOS HEADER
2. DOS Stub
3. IMAGE NT HEADERS
4. SECTION Table
5. Section


---
## 6. ELF 格式目标文件

- **分类**
	- 可重定位文件: 包括静态链接库
	- 可执行文件
	- 共享目标文件
	- 核心转储文件

目标文件按照属性不同将数据划分为多个节 section

**文件内容**
- ELF Header
- Program-head-table
  链接后存在
- Sections
	- .text(只读)
	- .data
		有初值全局变量和静态变量
	 - .bss
	    未初始化局部静态变量编译时一定存放在 .bss 节中
	    未初始化全局变量编译时不一定存放在 .bss 节中, 与编译器有关.
  
	- .rodata(只读)
		只读变量 (const 修饰), 字符串常量
	- .comment 编译器版本信息字符串
	- .debug 调试信息
	- .dynamic 动态链接信息
	- .hash 符号哈希表
	- .symtab 符号表
		- Elf32_Sym数组, 每个元素对应一个符号, 第一个元素无效.
		- 符号值st_value: 函数或变量地址
- Section-head-table 描述所有节的属性
	- 有n个节描述符 Elf32_Shdr,其中第一个为无效节描述符,共(n-1)个有效节.

- String table
	- .strtab 字符串表 : 保存普通字符串
	- .shstrtab 节头字符串表 : 保存节头表中用到的字符串(如, 节名)
- Symbol table
- Relocation table
	- 每个需要重定位的代码节或数据节都需要单独的重定位节
	- .rel.text
	- .rel.*



### 6.1 ELF Header 文件头
描述整个文件属性.

```cpp
typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number和其它信息 */
  Elf32_Half e_type;			/* Object file type */
  Elf32_Half e_machine;		/* Architecture */
  Elf32_Word e_version;		/* Object file version */
  Elf32_Addr e_entry;		/* Entry point virtual address */
  Elf32_Off	e_phoff;		/* Program header table file offset */
  Elf32_Off	e_shoff;		/* Section header table file offset */
  Elf32_Word e_flags;		/* Processor-specific flags */
  Elf32_Half e_ehsize;		/* ELF header size in bytes */
  Elf32_Half e_phentsize;	/* Program header table entry size */
  Elf32_Half e_phnum;		/* Program header table entry count */
  Elf32_Half e_shentsize;	/* Section header table entry size */
  Elf32_Half e_shnum;		/* Section header table entry count */
  Elf32_Half e_shstrndx;	/* Section header string table index */
} Elf32_Ehdr;

typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
  Elf64_Half e_type;		/* Object file type */
  Elf64_Half e_machine;		/* Architecture */
  Elf64_Word e_version;		/* Object file version */
  Elf64_Addr e_entry;		/* Entry point virtual address */
  Elf64_Off	e_phoff;		/* Program header table file offset */
  Elf64_Off	e_shoff;		/* Section header table file offset */
  Elf64_Word e_flags;		/* Processor-specific flags */
  Elf64_Half e_ehsize;		/* ELF header size in bytes */
  Elf64_Half e_phentsize;	/* Program header table entry size */
  Elf64_Half e_phnum;		/* Program header table entry count */
  Elf64_Half e_shentsize;	/* Section header table entry size */
  Elf64_Half e_shnum;		/* Section header table entry count */
  Elf64_Half e_shstrndx;	/* Section header string table index */
} Elf64_Ehdr;
```

![[ELF FILE (1).pdf|500]]

- MagicNum 中包含
	- Magic: 
		-  `0 x7F, 0x45 ,0x4c, 0x46`
		-  DEL "ELF"
	- ELF文件类型
		- 0 : 无效
		- 1 : 32bit
		- 2 : 64bit
	- 字节序: 大小端
		- 0: 无效
		- 1: 小端
		- 2: 大端
	- ELF版本
		- 01
	- OS/ABI
	- ABI 版本
- etype
	- 1可重定位, 2可执行, 3共享
- emachine
	- 3 intelx86

`readelf -h file`
![[Pasted image 20240603212107.png]]
### 6.2 Program-head-table
在可执行ELF文件中必需, 可链接文件中可选.

通过program header来获得每个segment的属性, 通过section header来获得每个section的属性

```c
#define EI_NIDENT(16)
typedef struct
{
  unsigned char e_ident[EI_NIDENT];/* Magic number and other info */
  Elf32_Half    e_type;         /* Object file type */
  Elf32_Half    e_machine;      /* Architecture */
  Elf32_Word    e_version;      /* Object file version */
  Elf32_Addr    e_entry;        /* Entry point virtual address */
  Elf32_Off	    e_phoff;        /* Program header table file offset */
  Elf32_Off	    e_shoff;        /* Section header table file offset */
  Elf32_Word    e_flags;        /* Processor-specific flags */
  Elf32_Half    e_ehsize;       /* ELF header size in bytes */
  Elf32_Half    e_phentsize;    /* Program header table entry size */
  Elf32_Half    e_phnum;        /* Program header table entry count */
  Elf32_Half    e_shentsize;    /* Section header table entry size */
  Elf32_Half    e_shnum;        /* Section header table entry count */
  Elf32_Half    e_shstrndx;    /* Section header string table index */
} Elf32_Ehdr;
```


### 6.3 Sections 节

#### 重定位表 .rel.*

.rel.text

#### 字符串表 .strtab
将所有字符串集中到一个表中, 利用偏移使用不同的字符串
保存普通字符串
- 符号名

#### 节头表字符串表 .shstrtab
保存节头表中使用的字符串:
- 节名

#### 符号表 .symtab
记录了目标文件中用到的所有符号, 每个符号拥有对应符号值, 即地址.

符号表中符号:
- 定义在本目标文件中全局符号
- 本目标文件引用的外部符号
- 节名, 值为该节的起始地址
- 局部符号, 编译内部可见, 对链接无任何作用
- 行号信息, 可选

**链接只考虑全局符号和外部符号.**

符号表由多个 Elf32_Sym 结构体组成, 第一个元素为无效的未定义符号.
```c
struct Elf32_Sym  
{  
  Elf32_Word    st_name;   /* Symbol name (string tbl index) */  
  Elf32_Addr    st_value;  /* Symbol value */  
  Elf32_Word    st_size;   /* Symbol size */  
  unsigned char st_info;   /* Symbol type and binding */  
  unsigned char st_other;  /* Symbol visibility */  
  Elf32_Section st_shndx;  /* Section index */  
};  
struct Elf64_Sym  
{  
  Elf64_Word    st_name;   /* Symbol name (string tbl index) */  
  unsigned char st_info;   /* Symbol type and binding */  
  unsigned char st_other;  /* Symbol visibility */  
  Elf64_Section st_shndx;  /* Section index */  
  Elf64_Addr    st_value;  /* Symbol value */  
  Elf64_Xword   st_size;   /* Symbol size */  
};
```




### 6.4 Section-head-table 节头表

包含多个**节描述符** ( Elf32_Shdr 结构体), 从中可以得到每个节的所有信息.
- 节名
- 节长度
- 文件中的偏移
- 读写权限
- 其他节属性 

第一个元素是无效节描述符, 可链接文件必有, 可执行文件可选.
通过program header来获得每个segment的属性, 通过section header来获得每个section的属性

```c
typedef struct{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number和其它信息 */
  Elf32_Half	e_type;			/* Object file type */
  Elf32_Half	e_machine;		/* Architecture */
  Elf32_Word	e_version;		/* Object file version */
  Elf32_Addr	e_entry;		/* Entry point virtual address */
  Elf32_Off	    e_phoff;		/* Program header table file offset */
  Elf32_Off	    e_shoff;		/* Section header table file offset */
  Elf32_Word	e_flags;		/* Processor-specific flags */
  Elf32_Half	e_ehsize;		/* ELF header size in bytes */
  Elf32_Half	e_phentsize;	/* Program header table entry size */
  Elf32_Half	e_phnum;		/* Program header table entry count */
  Elf32_Half	e_shentsize;	/* Section header table entry size */
  Elf32_Half	e_shnum;		/* Section header table entry count */
  Elf32_Half	e_shstrndx;	   /* Section header string table index */
} Elf32_Ehdr;

typedef struct{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
  Elf64_Half	e_type;			/* Object file type */
  Elf64_Half	e_machine;		/* Architecture */
  Elf64_Word	e_version;		/* Object file version */
  Elf64_Addr	e_entry;		/* Entry point virtual address */
  Elf64_Off	    e_phoff;		/* Program header table file offset */
  Elf64_Off	    e_shoff;		/* Section header table file offset */
  Elf64_Word	e_flags;		/* Processor-specific flags */
  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
  Elf64_Half	e_phentsize;	/* Program header table entry size */
  Elf64_Half	e_phnum;		/* Program header table entry count */
  Elf64_Half	e_shentsize;	/* Section header table entry size */
  Elf64_Half	e_shnum;		/* Section header table entry count */
  Elf64_Half	e_shstrndx;	   /* Section header string table index */
} Elf64_Ehdr;
```

| 记号       | 含义       |
| -------- | -------- |
| Name     | 节名       |
| Type     | SHT_REL  |
| Address  | 地址       |
| File off | 偏移量 Byte |
| Size     | 节大小 Byte |
| ES       |          |
| Flag     |          |
| LK       |          |
| Inf      |          |
| Al       |          |

![[Pasted image 20240603232545.png|675]]

---
## 7. 程序的装载

#### 一、装载的方式

页映射：将内存和磁盘中的数据和指令按照页为单位划分，以后装载和操作的单位就是页。4kb

#### 二、程序的装载运行步骤

1. 创建一个独立的虚拟地址空间；（虚拟页到物理页的映射关系，此时为空即可，缺页错误时会自动设置）
2. 读取可执行文件头，建立虚拟地址空间和可执行文件的映射关系；
3. 动态链接的过程；
4. 将CPU指令寄存器设置为可执行文件的入口地址（ELF文件头有存储），启动运行；（这个入口是运行库的入口函数）
5. 入口函数对运行库和程序运行环境进行初始化，包括堆、IO、线程、全局变量构造等等；
6. 入口函数完成初始化过程，调用main函数，正式开始执行程序的主体部分；
7. main函数运行完毕，返回入口函数，入口函数进行清理工作：析构、堆销毁、关闭IO，然后系统调用结束进程；


### 内存读写权限配置

.rodata .text 只读




---
Author : orgaworl@outlook.com
Github : [orgaworl/Course-Notes: SDU CyberScience (github.com)](https://github.com/orgaworl/Course-Notes)
Create: `2024-06-03` `16:05`

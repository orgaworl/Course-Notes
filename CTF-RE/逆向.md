---
tags:
  - 安全
---
## 反汇编

- 反汇编
	- 静态
	- 动态
- 反编译

---
### 静态反汇编
静态反汇编工具目标: 将二进制中所有代码转换为人类可阅读或机器可处理的形式,以便进一步分析.

步骤如下
1. 二进制加载程序加载二进制文件进行处理
2. 找出二进制文件中所有机器指令  (⭐易出错)
3. 将指令反汇编为人类可读或机器可读形式.

良性ELF二进制文件
- GCC
#### 线性反汇编
以二进制形式遍历所有代码段,连续解码所有字节,将其解析为指令列表.

例: objdump

**存在问题**: 存在非指令字节(**inline data**)
- 例子
	- VS在代码段中插入跳转表
- 导致结果
	- 出现无效操作码
	- 数据字节对应有效操作码, 反汇编工具输出假指令.
	- 在变长操作码ISA上, 可能导致反汇编指令流不同步.
	- 即使反汇编工具自动化, 但不同步会导致丢失几条真实指令.
		(恶意程序可故意包含使反汇编工具不同步字节, 以隐藏程序行为)


#### 递归反汇编
从已知的入口点开始进入, 然后递归的跟随控制流来发现代码. (**对控制流敏感.**)

- 方案缺点
	- 很难静态的找出间接跳转或调用的可能位置, 丢失简介跳转或调用的目标代码块.
- 应对
	- 使用特定的依赖于编译器的启发式方法解决控制流问题

switch => 跳转表, 使用了间接控制流

---
### 动态反汇编


- 缺点
	- 代码覆盖率
	- 只能看到运行期间实际执行的指令, 无法发现隐藏信息.

**恶意程序**检测到动态反汇编, 并隐藏自身行为.


#### 增加代码覆盖率

1. Test Suite
2. Fuzzing
3. 符号执行



---
### 结构化

图
- 控制流图CFG
- 全局CFG(过程间CFG), 即所有函数CFG的并集
- 调用图 CG


无法识别
- 面向对象代码无法识别, 因此二进制分析工具不区分面向对象和面向过程代码.
- 数据结构.
- 结构体和数组无法区分





---
## 反编译
翻译为高级语言. 过程极易出错, 仅限于手动逆向.



## 中间语言
IR (Intermediate Representation), 将具有复杂语义的指令转化为**语义完整更易分析**的语言.

$二进制=>汇编代码=>IR$


流行 IR
- REIL
- VEX IR
- LLVM IR

优点
- 简化复杂指令
- 抽象, 可将任意汇编语言先转化为 IR 再进行分析.



---
Author : orgaworl@outlook.com
Github : [orgaworl/Course-Notes: SDU CyberScience (github.com)](https://github.com/orgaworl/Course-Notes)
Create: `2024-05-13` `09:43`

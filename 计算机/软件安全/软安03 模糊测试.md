## 模糊测试
模糊测试（Fuzz testing）是一种发现安全漏洞的 有效的测试方法，通过向目标系统提供非预期的 输入并监视异常结果来发现软件漏洞

**1.按照智能化程度划分**
- Blind Fuzz：随机生成测试用例，不考虑数据结构 
- Smart Fuzz：生成测试用例时考虑数据结构以及编码方法
	- 面向逻辑(Logic Oriented Fuzzing)
	- 面向数据类型(Data Type Oriented Fuzzing)
	- 基于样本(Sample Based Fuzzing)(变异)

现代软件往往使用非常复杂的私有数据结构， 数据结构越复杂，解析程序的逻辑就越复杂，越容易出错

Blind Fuzz缺点：
对于采用复杂数据结构的复杂文件进行漏洞挖掘时
- 产生测试用例的策略缺少针对性
- 大量测试用例无效
- 难以发现复杂解析器深层逻辑的漏洞

**2.按照测试对象的信息获取程度**
- 黑盒Fuzz 在没有测试对象信息的情况下发送畸形的数据，不验证代码路径是否满足
- 白盒Fuzz 在有源代码的情况下，发送畸形的数据，验证目标代码路径是否满足 
- 灰盒Fuzz 在有部分代码信息的情况下发送畸形的数据，验证目标代码路径是否满足，如AFL


**3.按照测试用例生成方式进行划分：**
- 基于生成的Fuzz：按照定义好的测试用例模板生成测试用例，产生Fuzz测试数据
- 基于变异的Fuzz：通过随机种子结合变异生成测试用例，产生Fuzz测试数据

## 模糊测试中插桩

1. 编译期间的插桩(需要源代码，例子：AFL) 
2. 自定义调试器，使用断点来计算代码覆盖率(速度 比较慢)。 
3. 已经编译的程序上的动态插桩（无需源码，如PIN，Valgrind，） 
4. 直接向二进制文件插入代码的静态插桩技术，使用 的较少 
5. 使用硬件特性的动态插桩：
	IntelPT: 基于CPU硬件特性直接对二进制程序进行跟踪
---
date created: 2024-09-24 23:48
---

### 编译器

**GCC/MinGW**

**Clang+llvm**

**msvs**


### C++指针和引用的区别？

1. 指针有自己的内存地址，占四个字节（32位系统），而引用只是一个别名，没有专门的内存地址。
2. 指针可以被初始化为指向nullptr，而引用必须指向一个已有的对象。
3. 作为参数传递是，指针需要解引用( * )，而直接修改引用会改变原对象。
4. 指针可以多级，而引用最多一级。
5. 如果返回动态内存分配对象，必须用指针，否则可能引起内存泄漏.

### 讲一讲`int *p[n]` 和`int (*p)[n]`以及`int *p()`和`int (*p)()` 的区别。

- `int *p[n]` 表示p为**指针数组**。因为[]的优先级大于*，所以应该理解为 `int *(p[n])`。

- `int (*p)[n]` 表示p为**二维数组指针**, 指向一行有 n个元素的指针.

	```cpp
	int a[2][10];
	int (*p)[10]=a; //p指向数组a的首行。
	```

- `int *p()` 表示p为**函数，返回值类型为 `int*`;**

- `int (*p)()` 表示p为**函数指针，函数原型 `int func()`**。

> 注意函数指针不能++或--

## C++ 内存分配

### STL的两级分配器

为了提升内存管理效率，STL采用两级分配器：**对于大于128B的内存申请，采用第一级分配器**，用malloc(), realloc(), free()进行空间分配；**对于小于128B的内存申请，采用内存池技术**，采用链表进行管理。

### C++的内存池技术

C++默认的内存管理采用malloc(), free() 等，会频繁的在堆动态分配和回收内存，内存空间碎片化严重，导致空间利用率低。内存池很好的解决了这个问题，它是针对小对象而言的，首先申请一定数量，指定大小（通常8B）的内存块，当有新的内存申请就拿出一个块，如果不够再申请。

算法：

1. 预申请一个内存区chunk，将内存中按照对象大小划分成多个内存块block
2. 维持一个空闲内存块链表，通过指针相连，标记头指针为第一个空闲块
3. 每次新申请一个对象的空间，则将该内存块从空闲链表中去除，更新空闲链表头指针
4. 每次释放一个对象的空间，则重新将该内存块加到空闲链表头
5. 如果一个内存区占满了，则新开辟一个内存区，维持一个内存区的链表，同指针相连，头指针指向最新的内存区，新的内存块从该区内重新划分和申请

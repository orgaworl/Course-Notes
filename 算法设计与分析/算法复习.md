# 算法复习

## 1. Intro

### 1.1Concept

Algorithm Disign

- Modeling

- Disign

- Prove

- Evaluation

### 1.2 Algorithm

- Brute-Force

### 1.3 Problem

---

## 2. Complexity

### 2.1 Basic Concept

问题描述

- 指定问题的一组参数（集合、变量、函数、序列等），包括对域和它们之间关系的描述

- 解决方案的定义：由优化目标或约束条件决定

实例

- 参数的分配→ 问题的实例

算法

- 算法A是一个定义明确的、可由计算机执行的指令的有限序列，用于解决一类问题.

- 算法总是毫不含糊的.

- 用于执行计算、数据处理、自动推理和其他任务的规范.

问题P的算法A

- 将P的任何实例作为A的输入，每个步骤的计算都是确定的。

- A在有限的步骤中停止.

- 总是输出正确的解

Basic Computer Steps

- 抽象原子操作

Input size

- 实例的规模,对应一组问题.

算法效率度量

- 以输入规模的函数

### 2.2 three cases

- best

- worst

- averager

密码学中的困难问题假设要求在任意情况下都是困难的.

### 2.3 pseudocode

$$
Array\ P[0,...,n] \in R^{n+1}

$$

### 2.4 阶

上下界

- 紧上界/紧下界

- 松上界/松下界

notation

- 输入大小趋于正无穷时函数的极限
- $O/\Omega$ 能描述紧和松
- $o/\omega$  描述非紧
- $\Theta$      同时描述紧上下界

多变量notation

性质

- Big O
  
  - 传递链
  
  - 乘法
  
  - 加法

### 2.5 Example

- n个节点图,是否存在k个节点使得任意两个都不相连.

### 2.6 多项式时间

算法有效 <-> 多项式运行时间

---

## 4. DC

Select P

- 最大/最小/第二大
  
  线性

- general select
  
  $n\log n$
  
  $n\log k$
  
  $O(n)$

---

## 5. DP

根据子问题数量分类

1. $O(n)$
   
   - DAG                      $O(E)$
   
   - LIS 最长递增序列 $O(E)$
   
   - MIS 最大子段和   $O(N)$
   
   - 图像压缩              $O(256n)$

2. $O(n^2)$
   
   - 矩阵链乘 时间      $O(n^3)$
   
   - 最优二叉搜索树    $O(n^3)$

3. $O(nm)$
   
   - ROI  $O(nm^2)$
   
   - 背包 
   
   - 最长公共子序列
   
   - 编辑距离

---

## 6. Greedy

---

## 7. BACK

---

## 8. N&NP

1. NP-hard
   
   - 背包

2. NP-C
   
   - 0-1整数规划 (0-1背包)
   
   - 最大割
   
   - 背包

3. NP
   
   - SAT
   
   - 3-SAT
   
   - Hamiton

---

## 8. RandomA

## 9. ProblomSum

#### 排序问题:

#### 图论问题:

1. SSSP
   
   1. Dijistra
      
      每次选取一个离s最近的未知点, 用该点更新所有未知点的最短路径
   
   2. Bellman-Ford
      
      松弛n-1次,每次使用所有的边分别松弛, 更新到达该边目的点的最短路径. 

2. APSP
   
   1. Floyd-warshall
      
      根据任意两点之间的节点数进行迭代. 三重循环.
      
      ```c
      //初始化dist[][][0]
      dist[i][j][0]=min{ e[i][j],INF }
      //迭代
      for(int k=1;k<n;k++)
          for(int i=1;i<n;i++)
              for(int j=1;j<n;j++)
                  if(dist[i][k][k-1]+dist[k][j][k-1]<dist[i][j][k-1])
                      dist[i][j][k]= + ;
      ```

3. 最小生成树
   
   1. prime (node)
      
      每次选取一个离 S 最近的未知点, 用该更新所有未知点到S的距离.
      
      ```c
      while (true)
      {
          int best = -1;
          // 遍历所有未使用点，找到最优点( 与S最近的点 )
          for (int ord = 0; ord < nodeN; ord++)
          {
              if (!used[ord]&&(best == -1 || dist[ord] < dist[best])) 
              {
                  best = ord;
              }
          }
          // A. 未找到则结束
          if (best == -1){
              break;
          }
          // B. 找到则加入最小生成树.
          used[best] = true;
          res += dist[best];
          //更新 S 经过 best 到所有点的距离 dist
          for (int ord = 0; ord < nodeN; ord++)
          {
              dist[ord]=min(edge[best][ord], dist[ord]);
          }
      }
      ```

4. kruskal (edge)
   
   2|E| · O(log |V |)
   
   将所有边排序,不断选取不会产生环路的最短边,直到选取n-1条边.

5. 环路检查
   
   1. 并查集 检查无向图有无环路.
   
   2. 

6. TSP
    NP-hard problem

#### Knapsack背包问题

1. 可分背包问题 - 贪心

2. 有限数量限制背包
   
   0-1 背包   NP-hard DP

3. 无限可重背包

4. 多背包

5. 二维背包

背包问题的决策版本是N-P-COMPLETE。

#### 序列问题

1. 最长单调递增子序列
   
   - DP解法
   
   - 优化DP

2. 最长共同子序列

3. 最长

#### Other

- random access
  
  hash map $O(1)$

- Return on Investment (ROI) Problem
  
  DP

- Single Machine Scheduling(SMS) Problem
  
  Greedy:shortest processing time (SPT) first

- 素性检测
  
  - 暴力

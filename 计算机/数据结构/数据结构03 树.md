---
tags:
---
---
## 1. 树

- 定义
	- 树
	- 二叉树
	- 森林 
		- 森林是m（m≥0）棵互不相交的树的集合


- 属性
	- 结点的层次/深度 ——从上往下数 (默认从1开始)
	- 结点的高度 ——从下往上数
	- 树的高度/深度 ——总共多少层
	- 结点的度 ——有几个孩子（分支）
	- 树的度 ——各结点的度的最大值


- 性质
	- 结点数=总度数+1
	- 度为m的树 和 m叉树 的差别
	- 高度为h的m叉树至多有$\frac{m^h-1}{m-1}$个结点
	- 高度为h的m叉树至少有 h 个结点。
	- 高度为h、度为m的树至少有 h+m-1 个结点
	- 具有n个结点的m叉树的最小高度为 $\lceil log_m(n(m - 1) + 1)\rceil$

| 度为m的树                          | m叉树                          |
| ------------------------------ | ---------------------------- |
| 任意结点的度 ≤ m（最多m个孩子）             | 任意结点的度 ≤ m（最多m个孩子）           |
| 至少有一个结点度 = m（有m个孩子）            | 允许所有结点的度都 ＜ m                |
| 一定是非空树，至少有m+1个结点               | 可以是空树                        |
| 度为m的树第i层至多有 $m^{i-1}$ 个结点 (i≥1 | m叉树第i层至多有 $m^{i-1}$ 个结点 (i≥1 |


---
## 2. 二叉树
### 基础

二叉树是n（n≥0）个结点的有限集合：
1. 或者为空二叉树，即n = 0。
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。


- 特点：
	- 每个结点至多只有两棵子树 
	- 左右子树不能颠倒（二叉树是有序树）

- 性质
	设非空二叉树中度为0,1和2的结点个数分别为n0,n1和n2, 结点总数为n,则 
	- n0 = n2 + 1（叶子结点比二分支结点多一个）
	- n = n0 + n1 + n2
	- n = n1 + 2n2 +1


### 二叉树的遍历

- 分类
	- 先序遍历：根左右（NLR）
	- 中序遍历：左根右（LNR）
	- 后序遍历：左右根（LRN)
	- 层序遍历: 

- 遍历与算数表达式
	- 序遍历 - 前缀表达式
	- 中序遍历 - 中缀表达式（需要加界限符）
	- 后序遍历 - 后缀表达式

**遍历序列<=>二叉树**

给出一棵二叉树的 前/中/后/层序 遍历序列，不能唯一确定一棵二叉树.
- 可行组合方案
	- 中序+前序
	- 中序+后序
	- 中序+层序
- 前、后、层序三者的任意两两组合不可行

### 二叉树线索化







---
### 3. 特殊二叉树

#### 满二叉树
一棵高度为h，且含有$2^h-1$个结点的二叉树.

- 特点
	- 只有最后一层有叶子结点
	- 不存在度为 1 的结点
	- 按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父节点为 𝑖/2 （如果有的话）

![[Pasted image 20240508212023.png]]


#### 完全二叉树
当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树.

- 特点
	- 只有最后两层可能有叶子结点
	- 最多只有一个度为1的结点
	- 同满二叉树3
	-  i≤ 𝑛/2 为分支结点， i> 𝑛/2 为叶子结点

![[Pasted image 20240508212323.png]]

#### 二叉排序树
空二叉树，或者是具有如下性质的二叉树
- 左子树上所有结点的关键字均小于根结点的关键字；
- 右子树上所有结点的关键字均大于根结点的关键字。
- 左子树和右子树又各是一棵二叉排序树



#### 平衡二叉树

树上任一结点的左子树和右子树的深度之差不超过1。
平衡二叉树能有更高的搜索效率



---
## 4. 森林

- 森林(树) => 二叉树
	左指针作孩子指针
	右指针作兄弟指针



---
## 5. 并查集

### 基础

森林是m（m≥0）棵互不相交的树的集合, 用互不相交的树，表示多个“集合"

- 操作
	- 查找所属集合
		找到根节点
	- 判断两个元素是否属于同一个集合？
		判断两个元素根节点是否相同即
	- 合并集合
		让一棵树成为另一棵树的子树

- 树的顺序存储实现
	每个结点中保存指向父亲的"指针"

### 并查集

并查集( Disjoint Set）是逻辑结构-集合的一种具体实现，只进行“并”和“查”两种基本操作.

- 并查集操作
	- FIND  操作 $O(h)$
	- Union操作 $O(1)$

- 并查集实现优化1
	设根节点为树结点总数的负数
	让小树合并到大树,提高FIND速度.

	优化前FIND操作$O(h)$在最坏情况下为$O(n)$
	优化后FIND操作$O(h)$在最坏情况下为$O(\log n)$

- Find 操作的优化（压缩路径）
	在每次Find操作时将遍历过的节点挂载到根节点下,降低树的高度


## 最小堆/最大堆
通常是一个可以被看做一棵树的数组对象, 满足下列性质：
- 堆中某个节点的值总是不大于或不小于其父节点的值；
- 堆总是一棵完全二叉树。


**树的性质**:
- 节点从1开始, `[1,...,n]`
	- $n/2$	 为最后一个非叶节点
	- $n/2+1$为第一个叶节点
	- i     为当前节点
	- $i/2$   为其父节点
	- $2*i$  为左子节点
	- $2*i+1$ 为右子节点



- 节点从0开始
	- $n/2-1$ 为最后一个非叶节
	- $n/2$ 为第一个叶节点
	- i      为当前节点
	- $(i-1)/2$  $(i-2)/2$  为其父节点
	- $2*i+1$ 为左子节点
	- $2*i+2$ 为右子节点


### 核心操作

**shift Down**
```cpp
template <typename T>
bool maxHeap<T>::shiftDown(int pos)
{ 
	/* 
	当pos左右子树都为堆时,令pos shiftDown则可使整个树变成堆
	要求 pos 节点非叶节点, 因此必然存在左子节点
	*/
	if (pos < 0 || pos >= heap.size())
		return 0; // 检查正常输入
	else if (pos >= heap.size() / 2)
		return 1; // 叶节点无需进行操作

	T temp = heap[pos]; // 保存该位置数值
	int curPos = pos;
	int toCompare = this->leftChild(curPos); // 左节点必定存在
	while (toCompare < heap.size())
	{
		if (toCompare + 1 < heap.size() && heap[toCompare] < heap[toCompare + 1])
			toCompare++; // 选择子结点中更大的

		if (temp < heap[toCompare])
		{									// 若替换
			heap[curPos] = heap[toCompare]; // 上被下覆盖
			curPos = toCompare;
			toCompare =this->leftChild(curPos);
		}
		else{
			break;
		}
	}
	heap[curPos] = temp;
	return 1;
}
```


**shift Up**
```cpp
template <typename T>
bool maxHeap<T>::shiftUp(int pos)
{
	if (pos <= 0 || pos >= heap.size()) // 包含根节点情况
		return 0; 

	T temp = heap[pos]; // 保存该位置数值
	int curPos = pos;
	while (curPos > 0 && heap[parent(curPos)] < temp)
	{
		heap[curPos] = heap[parent(curPos)]; // 下被上覆盖
		curPos = parent(curPos);
	}
	heap[curPos] = temp;
	return 1;
}
```
### 初始化
```cpp
for (int i = curSize / 2 - 1; i >= 0; i--)
{
	shiftDown(i);
}
```
### 插入
```cpp
template <typename T>
bool maxHeap<T>::insert(const T nodeToInsert)
{
	heap.emplace_back(nodeToInsert);
	this->shiftUp(heap.size() - 1);
	return 1;
}
```

### 删除

任意位置
```cpp
template <typename T>
bool maxHeap<T>::remove(int pos, T &date)
{
	if (heap.size() <= 0 || pos < 0 || pos >= heap.size() )
	{
		return 0;
	}
	date = heap[pos]; // 传出被删除位置数值
	heap[pos] = heap[heap.size() - 1];
	heap.pop_back();
	this->shiftDown(pos);
	return 1;
}
```

```cpp
template <typename T>
bool maxHeap<T>::removeMax()
{
	if (heap.size() <= 0)
	{
		return 0;
	}
	heap[0] = heap[heap.size() - 1];
	heap.pop_back();
	this->shiftDown(0);
	return 1;
}
```
### 堆排序



---
Author : orgaworl@outlook.com
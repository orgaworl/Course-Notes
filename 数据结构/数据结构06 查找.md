---
tags:
---
---
## 基础概念

查找表
- 静态查找表: 主要关注查操作
- 动态查找表: 除了查操作还需要增/删元素.

算法效率评价-平均查找长度ASL
- 查找成功情况下ASL
- 查找失败情况下ASL


## 分块查找
又称索引顺序查找

算法过程如下：
1. 在索引表中确定待查记录所属的分块（可顺序/**二分** 查找）
2. 在块内顺序查找

将所有数据划分为多个块, 块内无序, 块之间有序.

索引表每个元素保存
- 对应分块的最大值
- 对应分块的位置区间

实现方式
- 顺序存储
- 链式存储


---
## 树形查找

### 二叉搜索树


### 平衡二叉树

### 红黑树



### B树 B+树










---
## 散列表


**冲突(碰撞)**
在散列表中插⼊⼀个数据元素时，需要根据关键字的值确定其存储地址，若该地址已经存储了其他元素，则称这种情况为  "冲突 (碰撞)".

**同义词**
若不同的关键字通过散列函数映射到同⼀个存储地址，则称它们为“同义词”.

### 减少冲突
构造更合理的HASH函数.
- 模素数取余
	关键字为整数情况
- 直接定址法

- 数字分析法
	选取数码分布较为均匀的若⼲位作为散列地址
	适⽤场景：关键字集合已知，且关键字的某⼏个数码位分布均匀

- 平⽅取中法 - 取关键字的平⽅值的中间⼏位作为散列地址。
	这种⽅法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布⽐较均匀。
	适⽤场景：关键字的每位取值都不够均匀


### 完全解决冲突


**拉链法（⼜称链接法、链地址法）**
	把所有“同义词”存储在⼀个链表


**开放定址法：**
 ⼀个散列地址，既对同义词开放，也对⾮同义词开放.如果发⽣“冲突”，就给新元素找另⼀个空闲位置.

发生第i次碰撞时的散列地址:
$$
H_i=(H(key)+d_i)\%m
$$


构造探测序列$d_i$
- 线性探测法 $d=\{0,1,2,...,m-1\}$
	探测覆盖所有空间
	
- 平方探测法 $d=\{0^2,1^2,-1^2,2^2,-2^2,...k^2,-k^2\},k\le\frac{m}{2}$
	不一定能覆盖所有空间( 散列表⻓度 m 是⼀个可以表示成4j + 3的素数则可行)
	
- 双散列法    $d_i=i\times hash_2(key)$
	双散列法未必能探测到散列表的所有位置。
	若hash2(key) 计算得到的值与散列表表⻓m互质，就能保证双散列发可以探测所有单元.
	
	常用方案: 令表⻓m本身就是质数，hash2(key)=m-(key%m)

- 伪随机序列 $d=\{ rand(), ... \}$




操作
- 查找元素
	由首个散列地址开始遍历
- 删除元素
	查找到后,添加已删除标记进行**逻辑删除**,与**置空**相区分
	新元素插入时可以插入到逻辑删除空间中.

可以定期整理hash表空间, 将空闲不用的逻辑删除区块利用起来

---
Author : orgaworl@outlook.com
---
tags:
  - 数据结构
  - C
---
---
## 线性表Linear List
线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列


### 顺序实现
逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现.
- 特点
	1. 随机访问，即可以在 O(1) 时间内找到第 i 个元素。
	2. 存储密度高，每个节点只存储数据元素
	3. 拓展容量不方便（即便采用动态分配, 拓展长度的时间复杂度也高）
	4. 插入、删除操作不方便，需要移动大量元素



### 链式实现

#### 单链表
- 实现
	- 头节点不存储数据, 统一逻辑, 否则搜索与插入操作都需要额外判断.
- 创建
	- 尾插法
		- 添加尾指针
	- 头插法


- 操作
	- 插入
		- 按序插入
		- 插入头部
		- 插入尾部
		- 插入指定节点后
		- 插入指定节点前,
			- 遍历找到前驱节点
			- 原节点拷贝插入后面, 新节点覆盖原节点位置
	- 删除
		- 按位序删除
			- 遍历
		- 删除指定节点
			- 遍历
			- 覆盖写实现(对删除最后一个节点无效)
	- 查找




#### 双链表

双方向

#### 循环链表

- 单循环链表
	尾节点next指向头节点
- 双循环链表
	尾节点next指向头节点
	头节点prior指向尾节点

优点:
从一个结点出发可以找到其他任何一个结点

#### 静态链表

静态链表：用数组的方式实现的链表, 分配一整片连续的内存空间，各个结点集中安置

- 节点组成
	- 数据
	- 下一节点地址(序号)
		指针取值:
		- 下一块地址
		- 空 -1
		- 空闲块 -2

```cpp
typedef struct{
	ElemType data;
	int next;
}SLinkList[10];

//头节点初始化
SLinkList[0].next=-1
```


优点：增、删 操作不需要大量移动元素
缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变

适用场景：1. 不支持指针的低级语言；2. 数据元素数量固定不变的场景（如操作系统的文件分配表FAT


### 顺序表和链式表


| 操作   | 顺序实现 | 链式实现 |
| ---- | ---- | ---- |
| 扩容   |      | √    |
| 增删   |      | √    |
| 按位查找 | √    |      |



---
## 栈
栈（Stack）是只允许在一端进行插入或删除操作的线性表.


### 顺序实现

#### 单栈

- 组成
	- 数组+栈顶指针

- 操作
	- 初始化
		`S.top=-1`
		`S.num=0`
	- 入栈 
		`S.data[++S.top]=x`
		`S.data[S.num++]=x`
	- 出栈 
		`x=S.data[S.top--]`
		`x=S.data[--S.num]`


#### 共享栈
- 组成
	- 数组+双指针

- 初始化
	```cpp
	S.top0=-1;
	S.top2=MaxSize;
	```
- 栈满条件
	- top0+1=top1


### 链式实现

#### 链表头为栈顶



### 栈的应用

#### 括号匹配: 表达式求值

- 算术表达式
	- 前缀表达式 波兰表达式
	- 中缀表达式 常用表达式
	- 后缀表达式 逆波兰表达式

**后缀相关**
- 中缀转后缀
	- 手动
		1. 确定中缀表达式中各个运算符的运算顺序 (左优先)
		2. 选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作
	- 自动
		从左到右处理各个元素, 直到末尾, 遇到三种情况：
		1. 遇到操作数。直接加入后缀表达式。
		2. 遇到界限符。
			1. 遇到“(”直接入栈；
			2. 遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。
		3. 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(” 或栈空则停止。之后再把当前运算符入栈.
		按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式


- 后缀求值: 
	- 手算
		从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合为一个操作数
	- 自动
		1. 从左往右扫描下一个元素，直到处理完所有元素.
		2. 若扫描到操作数则压入栈，并回到1；否则执行3.
		3. 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1.
		**先出栈的是“右操作数**


**前缀相关**
- 中缀转前缀
	- 手动
		1. 确定中缀表达式中各个运算符的运算顺序 (右优先)
		2. 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数
		3. 如果还有运算符没被处理，就继续 2

- 前缀求值

	- 用栈实现前缀表达式的计算：
		1. 从右往左扫描下一个元素，直到处理完所有元素
		2. 若扫描到操作数则压入栈，并回到1；否则执行3
		3. 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1. (**先弹出左操作数**)


**中缀相关**
- 中缀求值
	- 自动
		初始化两个栈，操作数栈和运算符栈.
		若扫描到操作数，压入操作数栈.
		若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈


#### 递归中栈

递归把原始问题转换为属性相同，但规模较小的问题.

- 常见递归规模
	- 线性增长
		- 求阶乘
	- 指数增长
		- 斐波那契数列

栈的缺点
- 包含大量重复计算
- 效率低
- 可能导致栈溢出



---
## 队列
队列（Queue）是只允许在一端进行插入，在另一端删除的线性表.


### 顺序实现(循环队列)

- 结构体组成
	- 数组 data
	- 队首指针 front
	- 队尾指针 rear

实现
- 基本实现
	rear指向将要插入新元素的位置.
	- 初始化 `rear=front=0`
	- 队列为空 `rear==fornt`
	- 队列已满 `(rear+1)%maxSize==front` 
		浪费一个元素空间
- 无浪费实现
	- A
		添加`size`变量
		- 队列为空 `rear==front && size==0`
		- 队列已满 `rear==front && size=MaxSize`, 无浪费
		
	- B
		添加tag变量, 记录最后一次操作,删除为0,添加为1,默认值为0.
		- 队列为空 `rear==front && tag==0`
		- 队列已满 `rear==front && tag==1`, 无浪费
	
- 其他实现
	- C
		修改rear指向最后一个元素位置
		- 初始化 `rear=-1` 
		- 增


**重点**: 使用冗余信息区分空队列和满队列
- 浪费一个元素的空间
- 使用辅助变量

### 链式实现

- 组成
	- 头尾指针
- 实现
	- 带头结点
		- 初始化`rear=front`
		- 为空`rear==front`
	- 不带头结点


### 双端队列



出栈元素排列可能性
卡塔兰数:
$$
\frac{1}{n+1}C_{2n}^{n}
$$

### 队列的应用

队列的特点: 先来先服务FCFS
- CPU调度
- 打印数据缓冲区
- 树的层次遍历

- 图的广度优先搜索


---
## 矩阵


### 对称矩阵的压缩存储

- 存储上三角矩阵
- 存储下三角矩阵
	- 按照行优先的顺序将元素存放入一维数组

### 三角矩阵


### 三对角矩阵(带状矩阵)


### 稀疏矩阵

稀疏矩阵以0元素为主

- 顺序存储——三元组 <行，列，值>



- 十字链表法













---
Author : orgaworl@outlook.com
# 算法设计与分析

---

## Lec00

印刷术与算法

- 算法原点: 十进制

- 算法>算术
  
  

### 计算机科学中算法

- Internet.  
  
  - Web search, packet routing, distributed file sharing, ...  

- Computer graphics. 
  
  - movies, video games, virtual reality, ...  

- Multimedia. 
  
  - MP3, JPG, DivX, HDTV ...  

- Artificial Intelligence. 
  
  - face recognition, PS, more AI algorithms  

- Social networks. 
  
  - recommendations, news feeds, advertisements, ...  

- Computers. 
  
  - circuit layout, databases, caching, compilers, ...  

- Biology. 
  
  - human genome project, protein folding, ...  

- Physics. 
  
  - N -body simulation, particle collision simulation, ...
    
    

### 密码算法

算法>密码学, 密码学是信息安全领域的算法

- honest parties can perform cryptographic algorithms eﬀiciently.

- malicious adversaries are unable to solve some problems .
  (no  eﬀicient algorithms against the security goal)
  
  

### 目标

算法设计：掌握解决问题的方法

1. abstract and formalize problem  

2. solve it eﬀiciently and correctly using algorithms  

3. prove its correctness

算法分析：培养严格的分析技能

1. 知道如何评估算法的性能

---

## Lec01

> 算法是一个有限的、确定的、有效的过程，有一些输入和一些输出。



#### Return on Investment (ROI) Problem

Modeling

![4afb48a5-7e04-44c0-8154-3b5c82b6abbe](file:///C:/Users/25137/Pictures/Typedown/4afb48a5-7e04-44c0-8154-3b5c82b6abbe.png)

- Brute-Force Algorithm: Universal Algorithm for All Problems
  通用的暴力穷举方法,依赖于计算机性能的增长.
  有效性: 每个可能的解向量都是方程的非负整数解
  复杂度
  solution1: 0-1序列数量
  ![2e10a32c-7624-4cf6-844c-1f6b7e676fc2](file:///C:/Users/25137/Pictures/Typedown/2e10a32c-7624-4cf6-844c-1f6b7e676fc2.png)
  solution2: 计算正整数解的个数
  
  

#### 单机调度问题 Single Machine Scheduling Problem

Modeling:

![6b3ec8c6-d145-48e6-a7c0-5e884c332e0d](file:///C:/Users/25137/Pictures/Typedown/6b3ec8c6-d145-48e6-a7c0-5e884c332e0d.png)

Solve: Greedy Algorithm(启发式算法)

    最短处理时间（SPT）优先

Correctness. 确保贪婪算法为所有实例产生最优解



### 背包问题 Knapsack problem (NP-complete problem)

贪婪算法失效.

    最高值重量比优先，重量限制为6

![451466e9-95e4-48fe-8a7f-1df165614052](file:///C:/Users/25137/Pictures/Typedown/451466e9-95e4-48fe-8a7f-1df165614052.png)



### 算法设计步骤

1. **Modeling.** give formal description of input, output and  objective function.

2. **Design.** Choose what algorithms? How to describe it?

3. **Prove.** 
   Correctness: yielding optimal solution for all instances.
   counterexample

4. **Analysis.** eﬀiciency: time and space

### 排序问题Sorting

#### 插入排序

Complexity analysis  

- worst-case: $O(n^2) $comparison and swap  

- best-case: $O(n)$ comparison and $O(1)$ swap  

- average-case: $O(n^2)$ comparison and swap  

用链表替换数组：将每轮的交换操作减少到恒定时间.



优点：

- simple.

- adaptive：对已经基本排序的数据集有效.

- stable：不更改键相等的元素的相对顺序

- inplace：只需要恒定的附加内存

- online：可以在接收数据集时对其进行排序.
  
  
  
  

#### 冒泡排序

Complexity analysis  

- worst-case: $O(n^2)$ comparison and swap  

- best-case:$O(n)$comparison and $O(1)$ swap  

- average-case: $O(n^2)$comparison and swap

Advantages.  Simple and stable  
Disadvantages. Inefficient, only for education purpose

#### 快排(divide and conquer)

**算法**

1. 选择枢轴 pivot 元素.  

2. Partitioning: 将数组重新排序为低子数组和高子数组，相等的值可以任意排列（或保持在中间）。分区之后，枢轴处于其最终位置

3. Recursively: 递归应用于子数组

**Complexity analysis**

- worst-case: $O(n^2)$comparison and swap  (totally ordered or unordered)

- best-case: $O(n log n)$ comparison and $O(1)$ swap  

- average-case: $O(n log n)$ comparison and swap  

**Advantages**

- quick: gained widespread adoption.
  
  > (i) in Unix as the default library sort subroutine; 
  > (ii) it lent its name to the C standard library subroutine qsort; 
  > (iii) in the reference implementation of Java. 

**Properties**

- non-stable

- pivot-choice affect performance
  
  

#### 归并排序 Merge Sort (divide-and-conquer)

**算法**

1. divide. 将列表划分为n个有序子序列.

2. merge. 将有序子序列合并为有序完整序列.

典型情况$n=2^k$.

**Complexity analysis**

- worst-case, best-case, average-case: O(n log n) comparison  

- space: O(n) total with O(n) auxiliary (not in-place)

**Advantages**

- quick:
  
  > (i) Linux kernel for linked list; 
  > (ii) Android platform;  
  > (iii) default sort algorithm in python and Java  

**Property**

- stable

#### TOTAL

| Algorithm      | worst case   | best case    | average case | stable |
| -------------- | ------------ | ------------ | ------------ | ------ |
| insertion sort | $O(n^2)$     | $O(n)$       | $O(n^2)$     | yes    |
| bubble sort    | $O(n^2)$     | $O(n)$       | $O(n^2)$     | yes    |
| quick sort     | $O(n2)$      | $O(n log n)$ | $O(n log n)$ | no     |
| merge sort     | $O(n log n)$ | $O(n log n)$ | $O(n log n)$ | yes    |



### TSP问题 (NP-hard problem)

**Modeling**

![c40360ae-cfb6-4b21-a492-f325728dc568](file:///C:/Users/25137/Pictures/Typedown/c40360ae-cfb6-4b21-a492-f325728dc568.png)



### NP problem

NP-hard (非确定性多项式时间难度)

- 非正式地“至少和N P中最难的问题一样难”

- 一个NP-hard 的有效算法意味着所有NP问题的有效算法.

尚未找到“efficient”算法：

- 已知算法的复杂度至少是输入大小的指数函数级别.

- 无人证明有效算法 "non-existence"

# 



# 标准

 ---

## 1. 变量名

## 2. 参数传递

1. 普通参数直接传入

2. 传入数组携带数组长度.

3. 输出参数在前,输入参数在后(或相反)

4. 函数内部new出的堆区空间尽量在函数内部free

5. **函数应避免使用全局变量、静态局部变量和I/O操作**
   
   (优先进行函数式编程)

## 3. 传参方式

### - 传入数组

```cpp
// 1)传入已分配数组
char arr[len];
void func(char * arr,int len);

// 2)引用未分配指针
char * poi;
void func(char*&arr)
{
    poi=new char[len];
}
delete poi;
```

### - 传入结构体

```c
//结构体内尽量不用指针,避免忘记释放堆区空间.
#define MAX_LENGTH 10
struct st
{
    int ind;
    char arr[MAX_LENTH];
};

//以下方法使用局部变量生命周期短
// 1. 直接传入(无法修改变量值和内部值,一般用引用替换)
void func(st var);

// 2.1 引用(可对变量和内部属性进行修改)
void func(st &var);
st var;
func(var);

// 2.2 局部变量传入指针(只能修改内部属性)
void func(st*var)
st var;
func(&var);

//以下方法可跨越函数使用
// 3.1 传入已分配堆区指针
st* poi=new st;
void func(st *&poi) //函数内部为poi内部值进行修改
{
    poi->ind=0;
    memset(poi->arr,0,MAX_LENGTH);
}
free(poi);

// 3.2 引用未分配堆区指针(不推荐)
st* poi;
void func(st *&poi)
{
    poi=new st;
}
```

### - 传入class

```cpp
//类内尽量使用指针,避免使用数组,析构函数中释放堆区空间.
clsaa cls
{
    int ind;
    char * arr;
    struct *st;
}
cls()
{
    ind=0;
    arr=NULL;
    st=NULL;
}
~cls()
{
    delete arr;
    delete st;
}

//以下方法使用局部变量生命周期短
// 1. 直接传入(无法修改变量值和内部值,一般用引用替换)
void func(cls var)


// 2.1 引用(可对变量值进行修改)
void func(cls &var)
st var;
func(var);

// 2.2 局部变量传入指针(只能修改结构体内部)
void func(cls*var)
st var;
func(&var)

//以下方法可跨越函数使用
// 3.1 传入已分配堆区指针
cls* poi=new cls;
void func(cls *&poi)
{
    poi->ind=0;
    arr=new char[len];
    st=new st;
}
free(poi);

// 3.2 引用未分配堆区指针
cls* poi;
void func(cls *&poi)
{
    poi=new cls;
    // ---
}
```

## 4. 多文件项目

**每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。**

如果一个.c文件不需要对外公布任何接口,则其就不应当存在,除非它是程序的入口.

### **.h文件**

对外提供的函数声明、宏定义、类型定义

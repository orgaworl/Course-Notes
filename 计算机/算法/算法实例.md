---
tags:
---


双指针法
- 快慢指针: 检查是否为循环链表


# 应用

## 素数相关

 埃氏筛
 按顺序第一次遇到的一定是素数.
 ```cpp
 class Solution {
 public:
     int countPrimes(int n) {
         vector<int>isPrime(n,1);
         int count=0;
         for(int i=2;i<n;i++){
             if(isPrime[i]==1){
                 count++;
                 for(long long ord=(long long)i*i;ord<n;ord+=i)
                 {
                     isPrime[ord]=0;
                 }
             }
         }
         return count;
     }
 };
 ```

gcd
```cpp
int gcd(int a, int b) {
	while (b != 0) {
		int temp = a % b;
		a = b;
		b = temp;
	}
	return a;
}
```
## 树

数组并查集
```cpp
class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n=isConnected.size();
        if(n==0)
            return false;
        int *join=new int[n];
        for(int i=0;i<n;i++)
        {
            join[i]=i;
        }
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                if(isConnected[i][j]==1)
                {
                    //找到i集合代表
                    int sym=i;
                    while(sym!=join[sym])
                    {
                        sym=join[sym];
                    }

                    //将j集合所有代表添加到i集合
                    int poi=j;
                    while(poi!=join[poi])
                    {
                        int temp=poi;
                        poi=join[poi];
                        join[temp]=sym;
                    }
                    join[poi]=sym;
                
                }
                    
            }
        }
        // 重要,确保所有节点到根节点距离为1
        for(int i=0;i<n;i++)
        {
            int prev=join[i];
            if(join[prev]!=prev)
            {
                int dest=prev;
                while(dest!=join[dest])
                {
                    dest=join[dest];
                }
                join[i]=dest;
            }
        }
		//计数
        set<int>s;
        for(int i=0;i<n;i++)
        {
            s.insert(join[i]);
        }
        return s.size();

    }
};
```


二叉树 深度优先搜索 DFS 
```cpp
class Solution {
public:
    unordered_map <TreeNode*, int> f, g;

    void dfs(TreeNode* node) {
        if (!node) {
            return;
        }
        dfs(node->left);
        dfs(node->right);
        f[node] = node->val + g[node->left] + g[node->right];
        g[node] = max(f[node->left], g[node->left]) 
		        + max(f[node->right], g[node->right]);
    }

    int rob(TreeNode* root) {
        dfs(root);
        return max(f[root], g[root]);
    }
};
```
## DP
>当前 DP 计算只依赖于上一轮 DP 计算, 则使用一维数组可能会"写覆盖"导致出错, 可以改用二维数组或双一维数组. 



## 矩阵

### 二维前缀和

![[Pasted image 20240708162436.png]]
```cpp
class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int m=mat.size();
        int n=mat[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0]=mat[0][0];
	    // gen dp table
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(i==0 && j==0)
                {
                }
                else if(i==0 && j!=0)
                    dp[i][j]=dp[i][j-1]+mat[i][j];
                else if(i!=0 && j==0)
                    dp[i][j]=dp[i-1][j]+mat[i][j];
                else
                    dp[i][j]=dp[i][j-1]+dp[i-1][j]+mat[i][j]-dp[i-1][j-1];
            }
        }
	    // use dp table to cal all result
        vector<vector<int>> res(m,vector<int>(n,0));
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                int x1=j-k,x2=j+k,y1=i-k,y2=i+k;
                if(y1<=0)
                    y1=0;
                if(y2>=m)
                    y2=m-1;
                if (x1<=0)
                    x1=0;
                if(x2>=n)
                    x2=n-1;

                if(x1==0 && y1==0)
                {
                    res[i][j]=dp[y2][x2];
                }
                else if(x1==0 && y1!=0)
                {
                    res[i][j]=dp[y2][x2]-dp[y1-1][x2];
                }
                else if(x1!=0 && y1==0)
                {
                    res[i][j]=dp[y2][x2]-dp[y2][x1-1];
                }
                else if(x1!=0 && y1!=0)
                {
                    res[i][j]= dp[y2][x2]-dp[y1-1][x2] 
	                    -dp[y2][x1-1]+dp[y1-1][x1-1];
                } 
            }
        }
        return res;
    }
};
```



### **图-以中间节点个数和终点进行DP**
```cpp
int matrix[5][10];
class Solution {
public:
    int numWays(int n, vector<vector<int>>& relation, int k) {
        memset(matrix,0,50*4);
        for(int dis=0;dis<k;dis++)
        {
            for(auto p=relation.begin();p!=relation.end();p++)
            {
                int src=(*p)[0];
                int dst=(*p)[1];
                if(dis==0)
                {
                    if(src==0)
                        matrix[dis][dst]=1;
                }else
                {
                    if(matrix[dis-1][src]!=0)
                        matrix[dis][dst]+=matrix[dis-1][src];
                }
            }
        }
        return matrix[k-1][n-1];
    }
};
```

## 并查集

```cpp
int p[200000];
int find(int x) {
    if (p[x]!=x) {
        p[x] = find(p[x]);
    }
    return p[x];
}
void unite(int a, int b) {
    int pa = find(a), pb = find(b);
    if (pa == pb) return;
    p[pa] = pb;
}

class Solution {
public:
    bool validPath(int n, vector<vector<int>>& edges, 
				   int source, int destination) {
        for(int i=0;i<n;i++)
        {
            p[i]=i;
        }
        int m=edges.size();
        for(int i=0;i<m;i++)
        {
            int a=edges[i][0];
            int b=edges[i][1];
            unite(min(a,b),max(a,b));
        }
        if(find(source)==find(destination))
        {
            return true;
        }
        return false;
    }
};
```

## 栈
**以O(1)时间获取栈中所有元素的最小值**
添加额外栈保存不同状态下最小值.
```cpp
class MinStack {
public:
    vector<int> stack1;
    vector<int> stack2;
    /** initialize your data structure here. */
    MinStack() {
        stack1.clear();
        stack2.clear();
    }
    void push(int x) {
        if (stack1.size() == 0) {
            stack1.push_back(x);
            stack2.push_back(x);
        } else {
            stack1.push_back(x);
            int prev = stack2.back();
            stack2.push_back(prev < x ? prev : x);
        }
    }
    void pop() {
        stack1.pop_back();
        stack2.pop_back();
    }
    int top() { return stack1.back(); }
    int getMin() { return stack2.back(); }
};

```

## 滑动窗口
问题描述: 移动窗口，找到不超过限制的最大窗口.
```cpp
//移动窗口，找到满足条件的窗口
        int winsize = 0;//最大窗口的大小
        int left = 0;//窗口的左边界
        for (int i = 0; i < s.size(); i++) {
            //将当前字符加入窗口
            nums[s[i] - 'a']--;
            //如果窗口不满足条件则不断移动左指针
            while (nums[s[i] - 'a'] < 0) {
                nums[s[left] - 'a']++;
                left++;
            }
            //更新最大窗口的结果
            winsize = max(winsize, i - left + 1);
        }
        //如果能取到，则返回对应的最小窗口（不能取到的情况开始就考虑过了）
        return s.size() - winsize;
```




---
Author : orgaworl@outlook.com
Github : [orgaworl/Course-Notes: SDU CyberScience (github.com)](https://github.com/orgaworl/Course-Notes)
Create: `2024-06-01` `21:15`



---
tags:
---
---
## 0. 基础概念

查找表
- 静态查找表: 主要关注查操作
- 动态查找表: 除了查操作还需要增/删元素.

算法效率评价-平均查找长度ASL
- 查找成功情况下ASL
- 查找失败情况下ASL


## 1. 分块查找
又称索引顺序查找

算法过程如下：
1. 在索引表中确定待查记录所属的分块（可顺序/**二分** 查找）
2. 在块内顺序查找

将所有数据划分为多个块, 块内无序, 块之间有序.

索引表每个元素保存
- 对应分块的最大值
- 对应分块的位置区间

实现方式
- 顺序存储
- 链式存储


---
## 2. 树形查找

### 2.1 二叉排序(查找树)树 BST

满足: 左子树节点值<根节点值<右子树节点值

中序遍历则可得到一个**递增**的有序序列

- 操作
	- 删除
		找到 左子树中最大值/右子树中最小值 替换被删除节点
		若只有一个子树,则可直接用子树根节点替换. 
		若是叶节点则直接删除
### 2.2 平衡二叉树AVL
定义
- BST
- 树上任意节点的左右子树深度不相差1.

$平衡因子=左子树深度-右子树深度\in\{-1,0,1\}$
```cpp
typedef struct AVLNode{
	int value;
	int balance;
	struct AVLNode *l,*r;
}AVLNode,*AVL;
```

#### 插入
关键点: 插入新节点后二叉树仍保持平衡
调整插入后**最小不平衡子树**
四种情况:
- LL
	A的左子右旋
	![[Pasted image 20240512150839.png]]

- RR
	A的右子 左旋
	![[Pasted image 20240512151853.png]]
- LR
	A的左子的右子 左旋+右旋
	无论插入节点在CL还是CR均成立.
	![[Pasted image 20240512152532.png]]
- RL
	A的右子的左子 右旋+左旋
	![[Pasted image 20240512152806.png]]

#### 删除

步骤
1. 先使用 "二叉排序树的删除" 对节点进行删除.
2. 从删除节点出发向上查找, 找到最小不平衡子树
3. 找到最深的儿子和孙子,并根据孙子位置调整平衡(LL/RR/LR/RL).
4. 若不平衡性向上传递,则继续回到 2.





### 2.3 红黑树 Red-Black Treee
红黑树定义
- BST
- 红黑特性
	- 任意节点都必须取黑色或红色
	- 根节点为黑色, 叶节点为黑
	- 不存在两个相邻的红节点
	- 每个节点到任一叶节点的简单路径上的黑节点个数相同

```cpp
struct RBNode{
	int key;
	RBNode*parent;
	RBNode*l;
	RBNode*r;
	int color;
}
```

黑高: 从该结点出发到达任意叶节点路径上的 黑节点总数

性质:
- 从根节点到叶节点的最长路径不大于最短路径的两倍.
- 有n个内部节点的红黑树高度$h\le 2\log_2(n+1)$
- 红黑树查找时间复杂度$=O(\log_2n)$



**AVL与RBT对比**

AVL 的插入删除操作容易破坏平衡状态, 需要频繁调整树的状态.

而RBT在插入删除操作在大部分时候都不会破坏"红黑"性质, 无需频繁调整树的状态, 调整也可在常数时间内完成.

AVL 适用于以查为主
RBT 适用于插删都有的场景, 更加实用.
#### 插入




 


#### 删除







### 2.4 B树 B+树

B树为多路平衡查找树.











---
## 3. 散列表


**冲突(碰撞)**
在散列表中插⼊⼀个数据元素时，需要根据关键字的值确定其存储地址，若该地址已经存储了其他元素，则称这种情况为  "冲突 (碰撞)".

**同义词**
若不同的关键字通过散列函数映射到同⼀个存储地址，则称它们为“同义词”.

### 减少冲突
构造更合理的HASH函数.
- 模素数取余
	关键字为整数情况
- 直接定址法

- 数字分析法
	选取数码分布较为均匀的若⼲位作为散列地址
	适⽤场景：关键字集合已知，且关键字的某⼏个数码位分布均匀

- 平⽅取中法 - 取关键字的平⽅值的中间⼏位作为散列地址。
	这种⽅法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布⽐较均匀。
	适⽤场景：关键字的每位取值都不够均匀


### 完全解决冲突


**拉链法（⼜称链接法、链地址法）**
	把所有“同义词”存储在⼀个链表


**开放定址法：**
 ⼀个散列地址，既对同义词开放，也对⾮同义词开放.如果发⽣“冲突”，就给新元素找另⼀个空闲位置.

发生第i次碰撞时的散列地址:
$$
H_i=(H(key)+d_i)\%m
$$


构造探测序列$d_i$
- 线性探测法 $d=\{0,1,2,...,m-1\}$
	探测覆盖所有空间
	
- 平方探测法 $d=\{0^2,1^2,-1^2,2^2,-2^2,...k^2,-k^2\},k\le\frac{m}{2}$
	不一定能覆盖所有空间( 散列表⻓度 m 是⼀个可以表示成4j + 3的素数则可行)
	
- 双散列法    $d_i=i\times hash_2(key)$
	双散列法未必能探测到散列表的所有位置。
	若hash2(key) 计算得到的值与散列表表⻓m互质，就能保证双散列发可以探测所有单元.
	
	常用方案: 令表⻓m本身就是质数，hash2(key)=m-(key%m)

- 伪随机序列 $d=\{ rand(), ... \}$




操作
- 查找元素
	由首个散列地址开始遍历
- 删除元素
	查找到后,添加已删除标记进行**逻辑删除**,与**置空**相区分
	新元素插入时可以插入到逻辑删除空间中.

可以定期整理hash表空间, 将空闲不用的逻辑删除区块利用起来

---
Author : orgaworl@outlook.com
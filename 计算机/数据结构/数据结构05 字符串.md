---
tags:
  - 数据结构
---
---

## 字符串基础

串是一种特殊的线性表，数据元素之间呈线性关系.


### 操作
- 比较
	- 字典序进行比较


### 实现
#### 顺序实现

- 长度单独作为变量实现.
- 长度数据存放在数组首元素中.
- 不记录数组长度.






#### 链式实现
每个节点保存多个char类型, 提升空间利用率 .


## 字符串模式匹配

### 朴素模式匹配
$$
T=(n-m+1)(m)=O(mn)
$$


### KMP算法

#### 时间复杂度分析
求 next 数组时间复杂度 O(m), 模式匹配过程最坏时间复杂度 O(n)
$$
T=O(m+n)
$$


#### 1. 计算next数组

【由模式串得到next数组】

进行多次循环，每次循环算出这次的next值。
进行每一次循环时，假设上一次循环得到的最大相同前后缀数为k，则此次循环中需要只比较s[j]与t[k]，根据比较结果不同存在两种情况：

1.两者相等，则此次的k为上次循环的k加一，然后进入下次循环。

2.两者不相等，则则令t[k]回退，直至两者相等或k为0，得到此次的k值，进入下次循环。

循环执行完毕，得到next数组的值。

```cpp
	//*begin计算next数组
    int* next = new int[tLength];
    int j = 0;    //j为模式串指针
    int k = 0;    //k为最大相同前后缀
    next[0] = 0;
    if (tLength >=2)
    {
        for (j = 1; j <=(tLength - 1); j++)
        {
             //不等时,循环直至k==0或相等
             while (k > 0 && t[j] != t[k])
                 k = next[k - 1];        
             //相等时,简单令k++
             if (t[j] == t[k])
             {
                 k++;
             }
             next[j] = k;
        }
    }
```
#### 2. 利用next数组实现KMP

```cpp
	//*begin进行比较
    int i = 0;
     j = 0;
    while (1)
    {
        if ((tLength + i + 1) == sLength)
        {
             //过程中模式串超出最大范围,可直接判定不存在
             return -1;
        }
        int mark = j + i;//防止陷入死循环
        while (t[j] == s[i]&&t[j]!='\0'&&s[i]!='\0')
        {
             i++;
             j++;
        }

        if (j== tLength)
        {
             return (i- tLength); //找到匹配串
        }
        else
        {
             //遇到不同
             if (j==0)
                 j = next[0];
             else
                 j = next[j - 1];
        }
        if (mark == j + i)//防止陷入死循环：如i+j的数值没变化则主串指针后移
        {
             i++;
             j = 0;
        }
    }
```

```cpp
int i=0,j=0;
while(i<=S.length-1 && j<=T.length-1){
	if(j==-1 || S.data[i]==T.data[j]){
		i++;
		j++;
	}
	else{
		j=next[j];
	}
	if(j>=T.length)
		return (i-T.length);
	else
		return 0;




}
```

example:
![[Pasted image 20240508201657.png]]


---
Author : orgaworl@outlook.com